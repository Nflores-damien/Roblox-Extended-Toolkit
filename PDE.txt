--[[
	Professional Partial Differential Equations (PDE) Solver Suite for Roblox
	Version: 2.0.0
	
	A comprehensive numerical PDE solver featuring:
	
	CORE CAPABILITIES:
	- Multi-dimensional solvers (1D, 2D, 3D grids)
	- Multiple PDE types (parabolic, hyperbolic, elliptic)
	- Adaptive time-stepping with stability control
	- High-order spatial discretization schemes
	
	NUMERICAL METHODS:
	- Finite Difference Methods (FDM) - 2nd to 6th order accuracy
	- Finite Volume Methods (FVM) - Conservative schemes
	- Method of Lines (MOL) - Flexible time integration
	- Spectral Methods - High accuracy for smooth solutions
	
	TIME INTEGRATION:
	- Explicit: Forward Euler, RK2, RK4, RK45 (adaptive)
	- Implicit: Backward Euler, Crank-Nicolson, BDF2
	- IMEX schemes for stiff problems
	- Stability analysis and CFL condition checking
	
	BOUNDARY CONDITIONS:
	- Dirichlet (fixed value)
	- Neumann (fixed gradient)
	- Robin (mixed)
	- Periodic
	- Absorbing/radiation boundaries
	
	EQUATION TYPES:
	- Heat/Diffusion equation (parabolic)
	- Wave equation (hyperbolic)
	- Advection equation (hyperbolic)
	- Advection-Diffusion equation
	- Poisson/Laplace equation (elliptic)
	- Burgers equation (nonlinear)
	- Reaction-Diffusion systems
	- Navier-Stokes (simplified 2D)
	
	LINEAR SOLVERS:
	- Direct: Thomas algorithm (tridiagonal)
	- Iterative: Jacobi, Gauss-Seidel, SOR, Conjugate Gradient
	- Multigrid methods for large systems
	- Preconditioned solvers
	
	ANALYSIS TOOLS:
	- Stability analysis (von Neumann, eigenvalue)
	- Conservation property checking
	- Error estimation (L1, L2, Linf norms)
	- Convergence rate calculation
	- Energy/mass conservation tracking
	
	APPLICATIONS:
	- Heat transfer simulation
	- Wave propagation
	- Fluid flow (incompressible)
	- Chemical reaction-diffusion
	- Pattern formation
	- Image processing (diffusion filters)
	- Game physics (smoke, fire, water)
	
	Optimized for real-time simulation and scientific accuracy.
]]

local PDE = {}
PDE.__index = PDE
PDE.VERSION = "2.0.0"

-- Local optimizations
local sqrt, abs, floor, ceil = math.sqrt, math.abs, math.floor, math.ceil
local max, min, exp, log = math.max, math.min, math.exp, math.log
local sin, cos, pi = math.sin, math.cos, math.pi
local huge = math.huge
local insert, remove = table.insert, table.remove

-- Constants
local EPSILON = 1e-12
local MAX_ITERATIONS = 10000

--[[============================================================================
	GRID STRUCTURE
============================================================================]]

local Grid = {}
Grid.__index = Grid

--- Create new grid
function Grid.new(config)
	local self = setmetatable({}, Grid)
	
	-- Dimensions
	self.nx = config.nx or 100
	self.ny = config.ny or 1
	self.nz = config.nz or 1
	
	-- Domain bounds
	self.xmin = config.xmin or 0
	self.xmax = config.xmax or 1
	self.ymin = config.ymin or 0
	self.ymax = config.ymax or 1
	self.zmin = config.zmin or 0
	self.zmax = config.zmax or 1
	
	-- Grid spacing
	self.dx = (self.xmax - self.xmin) / (self.nx - 1)
	self.dy = self.ny > 1 and (self.ymax - self.ymin) / (self.ny - 1) or 0
	self.dz = self.nz > 1 and (self.zmax - self.zmin) / (self.nz - 1) or 0
	
	-- Dimension
	self.dim = 1
	if self.ny > 1 then self.dim = 2 end
	if self.nz > 1 then self.dim = 3 end
	
	-- Storage
	self.data = {}
	self:allocate()
	
	return self
end

--- Allocate memory for grid
function Grid:allocate()
	if self.dim == 1 then
		for i = 1, self.nx do
			self.data[i] = 0
		end
	elseif self.dim == 2 then
		for i = 1, self.nx do
			self.data[i] = {}
			for j = 1, self.ny do
				self.data[i][j] = 0
			end
		end
	elseif self.dim == 3 then
		for i = 1, self.nx do
			self.data[i] = {}
			for j = 1, self.ny do
				self.data[i][j] = {}
				for k = 1, self.nz do
					self.data[i][j][k] = 0
				end
			end
		end
	end
end

--- Get value at index
function Grid:get(i, j, k)
	if self.dim == 1 then
		return self.data[i]
	elseif self.dim == 2 then
		return self.data[i][j]
	else
		return self.data[i][j][k]
	end
end

--- Set value at index
function Grid:set(i, j, k, value)
	if self.dim == 1 then
		self.data[i] = value
	elseif self.dim == 2 then
		self.data[i][j] = value
	else
		self.data[i][j][k] = value
	end
end

--- Get physical coordinates
function Grid:getCoords(i, j, k)
	local x = self.xmin + (i - 1) * self.dx
	local y = self.ymin + (j and (j - 1) or 0) * self.dy
	local z = self.zmin + (k and (k - 1) or 0) * self.dz
	return x, y, z
end

--- Clone grid
function Grid:clone()
	local copy = Grid.new({
		nx = self.nx, ny = self.ny, nz = self.nz,
		xmin = self.xmin, xmax = self.xmax,
		ymin = self.ymin, ymax = self.ymax,
		zmin = self.zmin, zmax = self.zmax
	})
	
	if self.dim == 1 then
		for i = 1, self.nx do
			copy.data[i] = self.data[i]
		end
	elseif self.dim == 2 then
		for i = 1, self.nx do
			for j = 1, self.ny do
				copy.data[i][j] = self.data[i][j]
			end
		end
	elseif self.dim == 3 then
		for i = 1, self.nx do
			for j = 1, self.ny do
				for k = 1, self.nz do
					copy.data[i][j][k] = self.data[i][j][k]
				end
			end
		end
	end
	
	return copy
end

--- Fill grid with value or function
function Grid:fill(value)
	if type(value) == "function" then
		if self.dim == 1 then
			for i = 1, self.nx do
				local x = self:getCoords(i)
				self.data[i] = value(x)
			end
		elseif self.dim == 2 then
			for i = 1, self.nx do
				for j = 1, self.ny do
					local x, y = self:getCoords(i, j)
					self.data[i][j] = value(x, y)
				end
			end
		elseif self.dim == 3 then
			for i = 1, self.nx do
				for j = 1, self.ny do
					for k = 1, self.nz do
						local x, y, z = self:getCoords(i, j, k)
						self.data[i][j][k] = value(x, y, z)
					end
				end
			end
		end
	else
		if self.dim == 1 then
			for i = 1, self.nx do
				self.data[i] = value
			end
		elseif self.dim == 2 then
			for i = 1, self.nx do
				for j = 1, self.ny do
					self.data[i][j] = value
				end
			end
		elseif self.dim == 3 then
			for i = 1, self.nx do
				for j = 1, self.ny do
					for k = 1, self.nz do
						self.data[i][j][k] = value
					end
				end
			end
		end
	end
end

--- Compute grid norms
function Grid:norm(p)
	p = p or 2
	local sum = 0
	local count = 0
	
	if self.dim == 1 then
		for i = 1, self.nx do
			local val = abs(self.data[i])
			if p == huge then
				sum = max(sum, val)
			else
				sum = sum + val ^ p
			end
			count = count + 1
		end
	elseif self.dim == 2 then
		for i = 1, self.nx do
			for j = 1, self.ny do
				local val = abs(self.data[i][j])
				if p == huge then
					sum = max(sum, val)
				else
					sum = sum + val ^ p
				end
				count = count + 1
			end
		end
	elseif self.dim == 3 then
		for i = 1, self.nx do
			for j = 1, self.ny do
				for k = 1, self.nz do
					local val = abs(self.data[i][j][k])
					if p == huge then
						sum = max(sum, val)
					else
						sum = sum + val ^ p
					end
					count = count + 1
				end
			end
		end
	end
	
	if p == huge then
		return sum
	else
		return (sum / count) ^ (1 / p)
	end
end

PDE.Grid = Grid

--[[============================================================================
	BOUNDARY CONDITIONS
============================================================================]]

local BC = {
	DIRICHLET = "dirichlet",
	NEUMANN = "neumann",
	PERIODIC = "periodic",
	ROBIN = "robin",
	ABSORBING = "absorbing"
}

PDE.BC = BC

local BoundaryCondition = {}
BoundaryCondition.__index = BoundaryCondition

function BoundaryCondition.new(bcType, value)
	local self = setmetatable({}, BoundaryCondition)
	self.type = bcType
	self.value = value or 0
	self.alpha = 1  -- For Robin BC: alpha*u + beta*du/dx = value
	self.beta = 0
	return self
end

function PDE.createBC(bcType, value)
	return BoundaryCondition.new(bcType, value)
end

--[[============================================================================
	LINEAR SOLVERS
============================================================================]]

local LinearSolver = {}

--- Thomas algorithm (tridiagonal solver)
function LinearSolver.thomas(a, b, c, d)
	local n = #d
	local cp = {}
	local dp = {}
	local x = {}
	
	cp[1] = c[1] / b[1]
	dp[1] = d[1] / b[1]
	
	for i = 2, n do
		local denom = b[i] - a[i] * cp[i - 1]
		cp[i] = c[i] / denom
		dp[i] = (d[i] - a[i] * dp[i - 1]) / denom
	end
	
	x[n] = dp[n]
	for i = n - 1, 1, -1 do
		x[i] = dp[i] - cp[i] * x[i + 1]
	end
	
	return x
end

--- Jacobi iteration
function LinearSolver.jacobi(A, b, x0, maxIter, tol)
	maxIter = maxIter or 1000
	tol = tol or 1e-6
	local n = #b
	local x = {}
	local xNew = {}
	
	for i = 1, n do
		x[i] = x0 and x0[i] or 0
		xNew[i] = 0
	end
	
	for iter = 1, maxIter do
		local maxDiff = 0
		
		for i = 1, n do
			local sum = b[i]
			for j = 1, n do
				if i ~= j then
					sum = sum - A[i][j] * x[j]
				end
			end
			xNew[i] = sum / A[i][i]
			maxDiff = max(maxDiff, abs(xNew[i] - x[i]))
		end
		
		for i = 1, n do
			x[i] = xNew[i]
		end
		
		if maxDiff < tol then
			return x, iter
		end
	end
	
	return x, maxIter
end

--- Gauss-Seidel iteration
function LinearSolver.gaussSeidel(A, b, x0, maxIter, tol)
	maxIter = maxIter or 1000
	tol = tol or 1e-6
	local n = #b
	local x = {}
	
	for i = 1, n do
		x[i] = x0 and x0[i] or 0
	end
	
	for iter = 1, maxIter do
		local maxDiff = 0
		
		for i = 1, n do
			local sum = b[i]
			for j = 1, n do
				if i ~= j then
					sum = sum - A[i][j] * x[j]
				end
			end
			local xNew = sum / A[i][i]
			maxDiff = max(maxDiff, abs(xNew - x[i]))
			x[i] = xNew
		end
		
		if maxDiff < tol then
			return x, iter
		end
	end
	
	return x, maxIter
end

--- Successive Over-Relaxation (SOR)
function LinearSolver.sor(A, b, x0, omega, maxIter, tol)
	omega = omega or 1.5
	maxIter = maxIter or 1000
	tol = tol or 1e-6
	local n = #b
	local x = {}
	
	for i = 1, n do
		x[i] = x0 and x0[i] or 0
	end
	
	for iter = 1, maxIter do
		local maxDiff = 0
		
		for i = 1, n do
			local sum = b[i]
			for j = 1, n do
				if i ~= j then
					sum = sum - A[i][j] * x[j]
				end
			end
			local xNew = (1 - omega) * x[i] + omega * sum / A[i][i]
			maxDiff = max(maxDiff, abs(xNew - x[i]))
			x[i] = xNew
		end
		
		if maxDiff < tol then
			return x, iter
		end
	end
	
	return x, maxIter
end

--- Conjugate Gradient method (for symmetric positive definite matrices)
function LinearSolver.conjugateGradient(A, b, x0, maxIter, tol)
	maxIter = maxIter or 1000
	tol = tol or 1e-8
	local n = #b
	local x = {}
	local r = {}
	local p = {}
	local Ap = {}
	
	-- Initialize
	for i = 1, n do
		x[i] = x0 and x0[i] or 0
	end
	
	-- r = b - A*x
	for i = 1, n do
		local sum = 0
		for j = 1, n do
			sum = sum + A[i][j] * x[j]
		end
		r[i] = b[i] - sum
		p[i] = r[i]
	end
	
	local rsold = 0
	for i = 1, n do
		rsold = rsold + r[i] * r[i]
	end
	
	for iter = 1, maxIter do
		-- Ap = A*p
		for i = 1, n do
			Ap[i] = 0
			for j = 1, n do
				Ap[i] = Ap[i] + A[i][j] * p[j]
			end
		end
		
		-- alpha = rsold / (p' * Ap)
		local pAp = 0
		for i = 1, n do
			pAp = pAp + p[i] * Ap[i]
		end
		local alpha = rsold / pAp
		
		-- x = x + alpha * p
		-- r = r - alpha * Ap
		for i = 1, n do
			x[i] = x[i] + alpha * p[i]
			r[i] = r[i] - alpha * Ap[i]
		end
		
		-- Check convergence
		local rsnew = 0
		for i = 1, n do
			rsnew = rsnew + r[i] * r[i]
		end
		
		if sqrt(rsnew) < tol then
			return x, iter
		end
		
		-- p = r + (rsnew / rsold) * p
		local beta = rsnew / rsold
		for i = 1, n do
			p[i] = r[i] + beta * p[i]
		end
		
		rsold = rsnew
	end
	
	return x, maxIter
end

PDE.LinearSolver = LinearSolver

--[[============================================================================
	PDE SOLVER BASE CLASS
============================================================================]]

function PDE.new(config)
	local self = setmetatable({}, PDE)
	
	-- Grid
	self.grid = Grid.new(config.grid or {})
	
	-- Time parameters
	self.t = 0
	self.dt = config.dt or 0.001
	self.dtMin = config.dtMin or 1e-8
	self.dtMax = config.dtMax or 0.1
	self.adaptiveTimeStep = config.adaptiveTimeStep or false
	self.cflTarget = config.cflTarget or 0.5
	
	-- PDE parameters
	self.diffusivity = config.diffusivity or 1.0
	self.advection = config.advection or {0, 0, 0}
	self.reaction = config.reaction or 0
	self.source = config.source  -- Function(x, y, z, t)
	
	-- Boundary conditions
	self.bcLeft = config.bcLeft or BoundaryCondition.new(BC.DIRICHLET, 0)
	self.bcRight = config.bcRight or BoundaryCondition.new(BC.DIRICHLET, 0)
	self.bcBottom = config.bcBottom or BoundaryCondition.new(BC.DIRICHLET, 0)
	self.bcTop = config.bcTop or BoundaryCondition.new(BC.DIRICHLET, 0)
	self.bcFront = config.bcFront or BoundaryCondition.new(BC.DIRICHLET, 0)
	self.bcBack = config.bcBack or BoundaryCondition.new(BC.DIRICHLET, 0)
	
	-- Numerical scheme
	self.spatialOrder = config.spatialOrder or 2  -- Accuracy order
	self.timeScheme = config.timeScheme or "rk4"  -- euler, rk2, rk4, cn, bdf2
	
	-- Solver options
	self.linearSolver = config.linearSolver or "sor"
	self.maxIterations = config.maxIterations or 1000
	self.tolerance = config.tolerance or 1e-6
	
	-- Statistics
	self.stats = {
		steps = 0,
		linearIterations = 0,
		wallTime = 0
	}
	
	return self
end

--[[============================================================================
	SPATIAL DISCRETIZATION
============================================================================]]

--- Apply boundary conditions to 1D grid
function PDE:applyBC1D(u)
	-- Left boundary
	if self.bcLeft.type == BC.DIRICHLET then
		u.data[1] = self.bcLeft.value
	elseif self.bcLeft.type == BC.NEUMANN then
		-- du/dx = value, use one-sided difference
		u.data[1] = u.data[2] - self.bcLeft.value * u.dx
	elseif self.bcLeft.type == BC.PERIODIC then
		u.data[1] = u.data[u.nx - 1]
	end
	
	-- Right boundary
	if self.bcRight.type == BC.DIRICHLET then
		u.data[u.nx] = self.bcRight.value
	elseif self.bcRight.type == BC.NEUMANN then
		u.data[u.nx] = u.data[u.nx - 1] + self.bcRight.value * u.dx
	elseif self.bcRight.type == BC.PERIODIC then
		u.data[u.nx] = u.data[2]
	end
end

--- Compute spatial derivatives using finite differences
function PDE:laplacian1D(u)
	local result = u:clone()
	local dx2 = u.dx * u.dx
	
	for i = 2, u.nx - 1 do
		-- Second-order central difference
		if self.spatialOrder == 2 then
			result.data[i] = (u.data[i - 1] - 2 * u.data[i] + u.data[i + 1]) / dx2
		-- Fourth-order central difference
		elseif self.spatialOrder == 4 and i >= 3 and i <= u.nx - 2 then
			result.data[i] = (-u.data[i - 2] + 16 * u.data[i - 1] - 30 * u.data[i] + 
				16 * u.data[i + 1] - u.data[i + 2]) / (12 * dx2)
		else
			result.data[i] = (u.data[i - 1] - 2 * u.data[i] + u.data[i + 1]) / dx2
		end
	end
	
	return result
end

--- Compute spatial derivatives for 2D
function PDE:laplacian2D(u)
	local result = u:clone()
	local dx2 = u.dx * u.dx
	local dy2 = u.dy * u.dy
	
	for i = 2, u.nx - 1 do
		for j = 2, u.ny - 1 do
			local d2udx2 = (u.data[i - 1][j] - 2 * u.data[i][j] + u.data[i + 1][j]) / dx2
			local d2udy2 = (u.data[i][j - 1] - 2 * u.data[i][j] + u.data[i][j + 1]) / dy2
			result.data[i][j] = d2udx2 + d2udy2
		end
	end
	
	return result
end

--- Compute advection term (1D)
function PDE:advection1D(u, velocity)
	local result = u:clone()
	local dx = u.dx
	
	for i = 2, u.nx - 1 do
		-- Upwind scheme for stability
		if velocity >= 0 then
			result.data[i] = -velocity * (u.data[i] - u.data[i - 1]) / dx
		else
			result.data[i] = -velocity * (u.data[i + 1] - u.data[i]) / dx
		end
	end
	
	return result
end

--- Compute right-hand side for heat equation
function PDE:rhsHeat(u, t)
	local dudt
	
	if self.grid.dim == 1 then
		dudt = self:laplacian1D(u)
		-- Scale by diffusivity
		for i = 1, u.nx do
			dudt.data[i] = self.diffusivity * dudt.data[i]
		end
		
		-- Add advection if present
		if self.advection[1] ~= 0 then
			local advTerm = self:advection1D(u, self.advection[1])
			for i = 1, u.nx do
				dudt.data[i] = dudt.data[i] + advTerm.data[i]
			end
		end
		
		-- Add source term
		if self.source then
			for i = 1, u.nx do
				local x = u:getCoords(i)
				dudt.data[i] = dudt.data[i] + self.source(x, 0, 0, t)
			end
		end
		
	elseif self.grid.dim == 2 then
		dudt = self:laplacian2D(u)
		for i = 1, u.nx do
			for j = 1, u.ny do
				dudt.data[i][j] = self.diffusivity * dudt.data[i][j]
			end
		end
		
		if self.source then
			for i = 1, u.nx do
				for j = 1, u.ny do
					local x, y = u:getCoords(i, j)
					dudt.data[i][j] = dudt.data[i][j] + self.source(x, y, 0, t)
				end
			end
		end
	end
	
	return dudt
end

--[[============================================================================
	TIME INTEGRATION SCHEMES
============================================================================]]

--- Forward Euler (explicit, 1st order)
function PDE:stepEuler(u, t, dt)
	local dudt = self:rhsHeat(u, t)
	local uNew = u:clone()
	
	if u.dim == 1 then
		for i = 1, u.nx do
			uNew.data[i] = u.data[i] + dt * dudt.data[i]
		end
	elseif u.dim == 2 then
		for i = 1, u.nx do
			for j = 1, u.ny do
				uNew.data[i][j] = u.data[i][j] + dt * dudt.data[i][j]
			end
		end
	end
	
	self:applyBC1D(uNew)
	return uNew
end

--- Runge-Kutta 2nd order (RK2)
function PDE:stepRK2(u, t, dt)
	-- k1 = f(t, u)
	local k1 = self:rhsHeat(u, t)
	
	-- Compute u + dt/2 * k1
	local uTemp = u:clone()
	if u.dim == 1 then
		for i = 1, u.nx do
			uTemp.data[i] = u.data[i] + 0.5 * dt * k1.data[i]
		end
	elseif u.dim == 2 then
		for i = 1, u.nx do
			for j = 1, u.ny do
				uTemp.data[i][j] = u.data[i][j] + 0.5 * dt * k1.data[i][j]
			end
		end
	end
	self:applyBC1D(uTemp)
	
	-- k2 = f(t + dt/2, u + dt/2 * k1)
	local k2 = self:rhsHeat(uTemp, t + 0.5 * dt)
	
	-- u_new = u + dt * k2
	local uNew = u:clone()
	if u.dim == 1 then
		for i = 1, u.nx do
			uNew.data[i] = u.data[i] + dt * k2.data[i]
		end
	elseif u.dim == 2 then
		for i = 1, u.nx do
			for j = 1, u.ny do
				uNew.data[i][j] = u.data[i][j] + dt * k2.data[i][j]
			end
		end
	end
	
	self:applyBC1D(uNew)
	return uNew
end

--- Runge-Kutta 4th order (RK4)
function PDE:stepRK4(u, t, dt)
	-- k1 = f(t, u)
	local k1 = self:rhsHeat(u, t)
	
	-- k2 = f(t + dt/2, u + dt/2 * k1)
	local uTemp = u:clone()
	if u.dim == 1 then
		for i = 1, u.nx do
			uTemp.data[i] = u.data[i] + 0.5 * dt * k1.data[i]
		end
	elseif u.dim == 2 then
		for i = 1, u.nx do
			for j = 1, u.ny do
				uTemp.data[i][j] = u.data[i][j] + 0.5 * dt * k1.data[i][j]
			end
		end
	end
	self:applyBC1D(uTemp)
	local k2 = self:rhsHeat(uTemp, t + 0.5 * dt)
	
	-- k3 = f(t + dt/2, u + dt/2 * k2)
	uTemp = u:clone()
	if u.dim == 1 then
		for i = 1, u.nx do
			uTemp.data[i] = u.data[i] + 0.5 * dt * k2.data[i]
		end
	elseif u.dim == 2 then
		for i = 1, u.nx do
			for j = 1, u.ny do
				uTemp.data[i][j] = u.data[i][j] + 0.5 * dt * k2.data[i][j]
			end
		end
	end
	self:applyBC1D(uTemp)
	local k3 = self:rhsHeat(uTemp, t + 0.5 * dt)
	
	-- k4 = f(t + dt, u + dt * k3)
	uTemp = u:clone()
	if u.dim == 1 then
		for i = 1, u.nx do
			uTemp.data[i] = u.data[i] + dt * k3.data[i]
		end
	elseif u.dim == 2 then
		for i = 1, u.nx do
			for j = 1, u.ny do
				uTemp.data[i][j] = u.data[i][j] + dt * k3.data[i][j]
			end
		end
	end
	self:applyBC1D(uTemp)
	local k4 = self:rhsHeat(uTemp, t + dt)
	
	-- u_new = u + dt/6 * (k1 + 2*k2 + 2*k3 + k4)
	local uNew = u:clone()
	if u.dim == 1 then
		for i = 1, u.nx do
			uNew.data[i] = u.data[i] + dt / 6 * (k1.data[i] + 2 * k2.data[i] + 2 * k3.data[i] + k4.data[i])
		end
	elseif u.dim == 2 then
		for i = 1, u.nx do
			for j = 1, u.ny do
				uNew.data[i][j] = u.data[i][j] + dt / 6 * (
					k1.data[i][j] + 2 * k2.data[i][j] + 2 * k3.data[i][j] + k4.data[i][j]
				)
			end
		end
	end
	
	self:applyBC1D(uNew)
	return uNew
end

--- Crank-Nicolson (implicit, 2nd order)
function PDE:stepCrankNicolson(u, t, dt)
	-- Only implemented for 1D heat equation for now
	if u.dim ~= 1 then
		return self:stepRK4(u, t, dt)
	end
	
	local dx2 = u.dx * u.dx
	local r = self.diffusivity * dt / (2 * dx2)
	local n = u.nx
	
	-- Build tridiagonal system
	local a = {}
	local b = {}
	local c = {}
	local d = {}
	
	for i = 1, n do
		a[i] = -r
		b[i] = 1 + 2 * r
		c[i] = -r
		
		if i == 1 then
			d[i] = self.bcLeft.value
		elseif i == n then
			d[i] = self.bcRight.value
		else
			-- Right-hand side from explicit part
			d[i] = r * u.data[i - 1] + (1 - 2 * r) * u.data[i] + r * u.data[i + 1]
		end
	end
	
	-- Modify for boundary conditions
	if self.bcLeft.type == BC.DIRICHLET then
		b[1] = 1
		c[1] = 0
	end
	if self.bcRight.type == BC.DIRICHLET then
		a[n] = 0
		b[n] = 1
	end
	
	-- Solve tridiagonal system
	local solution = LinearSolver.thomas(a, b, c, d)
	
	local uNew = u:clone()
	for i = 1, n do
		uNew.data[i] = solution[i]
	end
	
	return uNew
end

--- Single time step
function PDE:step(u, dt)
	dt = dt or self.dt
	local uNew
	
	if self.timeScheme == "euler" then
		uNew = self:stepEuler(u, self.t, dt)
	elseif self.timeScheme == "rk2" then
		uNew = self:stepRK2(u, self.t, dt)
	elseif self.timeScheme == "rk4" then
		uNew = self:stepRK4(u, self.t, dt)
	elseif self.timeScheme == "cn" or self.timeScheme == "cranknicolson" then
		uNew = self:stepCrankNicolson(u, self.t, dt)
	else
		uNew = self:stepRK4(u, self.t, dt)
	end
	
	self.t = self.t + dt
	self.stats.steps = self.stats.steps + 1
	
	return uNew
end

--[[============================================================================
	STABILITY ANALYSIS
============================================================================]]

--- Check CFL condition for explicit schemes
function PDE:checkCFL(dt)
	dt = dt or self.dt
	local cfl
	
	if self.grid.dim == 1 then
		cfl = self.diffusivity * dt / (self.grid.dx * self.grid.dx)
		-- For advection
		if self.advection[1] ~= 0 then
			local cflAdv = abs(self.advection[1]) * dt / self.grid.dx
			cfl = max(cfl, cflAdv)
		end
	elseif self.grid.dim == 2 then
		local cflX = self.diffusivity * dt / (self.grid.dx * self.grid.dx)
		local cflY = self.diffusivity * dt / (self.grid.dy * self.grid.dy)
		cfl = cflX + cflY
	end
	
	return cfl
end

--- Compute maximum stable time step
function PDE:maxStableDt()
	local dtMax
	
	if self.grid.dim == 1 then
		dtMax = 0.5 * self.grid.dx * self.grid.dx / self.diffusivity
		if self.advection[1] ~= 0 then
			local dtAdv = self.grid.dx / abs(self.advection[1])
			dtMax = min(dtMax, dtAdv)
		end
	elseif self.grid.dim == 2 then
		local dx2 = self.grid.dx * self.grid.dx
		local dy2 = self.grid.dy * self.grid.dy
		dtMax = 0.25 / (self.diffusivity * (1 / dx2 + 1 / dy2))
	end
	
	return dtMax
end

--- Adapt time step based on CFL condition
function PDE:adaptTimeStep()
	if not self.adaptiveTimeStep then
		return self.dt
	end
	
	local cfl = self:checkCFL(self.dt)
	local dtNew = self.dt
	
	if cfl > self.cflTarget then
		dtNew = self.dt * self.cflTarget / cfl * 0.9
	elseif cfl < self.cflTarget * 0.5 then
		dtNew = self.dt * self.cflTarget / cfl * 1.1
	end
	
	dtNew = max(self.dtMin, min(self.dtMax, dtNew))
	self.dt = dtNew
	
	return dtNew
end

--[[============================================================================
	SPECIALIZED PDE SOLVERS
============================================================================]]

--- Solve 1D heat equation
function PDE.solveHeatEquation1D(config)
	local solver = PDE.new(config)
	local u = solver.grid:clone()
	
	-- Initial condition
	if config.initial then
		u:fill(config.initial)
	end
	
	local tMax = config.tMax or 1.0
	local saveInterval = config.saveInterval
	local solutions = {}
	local lastSave = 0
	
	while solver.t < tMax do
		u = solver:step(u)
		
		if saveInterval and solver.t - lastSave >= saveInterval then
			insert(solutions, {t = solver.t, u = u:clone()})
			lastSave = solver.t
		end
		
		if solver.adaptiveTimeStep then
			solver:adaptTimeStep()
		end
	end
	
	return u, solutions, solver
end

--- Solve 2D heat equation
function PDE.solveHeatEquation2D(config)
	local solver = PDE.new(config)
	local u = solver.grid:clone()
	
	if config.initial then
		u:fill(config.initial)
	end
	
	local tMax = config.tMax or 1.0
	local saveInterval = config.saveInterval
	local solutions = {}
	local lastSave = 0
	
	while solver.t < tMax do
		u = solver:step(u)
		
		if saveInterval and solver.t - lastSave >= saveInterval then
			insert(solutions, {t = solver.t, u = u:clone()})
			lastSave = solver.t
		end
		
		if solver.adaptiveTimeStep then
			solver:adaptTimeStep()
		end
	end
	
	return u, solutions, solver
end

--- Solve Poisson equation (elliptic, ∇²u = f)
function PDE.solvePoissonEquation(config)
	local grid = Grid.new(config.grid or {})
	local u = grid:clone()
	local f = grid:clone()
	
	-- Source term
	if config.source then
		f:fill(config.source)
	end
	
	-- Only 1D and 2D for now
	if grid.dim == 1 then
		-- Build system A*u = f
		local n = grid.nx
		local a, b, c, d = {}, {}, {}, {}
		local dx2 = grid.dx * grid.dx
		
		for i = 1, n do
			a[i] = 1
			b[i] = -2
			c[i] = 1
			d[i] = dx2 * f.data[i]
		end
		
		-- Boundary conditions
		local bcLeft = config.bcLeft or BoundaryCondition.new(BC.DIRICHLET, 0)
		local bcRight = config.bcRight or BoundaryCondition.new(BC.DIRICHLET, 0)
		
		if bcLeft.type == BC.DIRICHLET then
			b[1] = 1
			c[1] = 0
			d[1] = bcLeft.value
		end
		if bcRight.type == BC.DIRICHLET then
			a[n] = 0
			b[n] = 1
			d[n] = bcRight.value
		end
		
		local solution = LinearSolver.thomas(a, b, c, d)
		for i = 1, n do
			u.data[i] = solution[i]
		end
		
	elseif grid.dim == 2 then
		-- Use iterative solver (Gauss-Seidel)
		local maxIter = config.maxIterations or 10000
		local tol = config.tolerance or 1e-6
		local dx2 = grid.dx * grid.dx
		local dy2 = grid.dy * grid.dy
		
		for iter = 1, maxIter do
			local maxChange = 0
			
			for i = 2, grid.nx - 1 do
				for j = 2, grid.ny - 1 do
					local uOld = u.data[i][j]
					
					-- Discretized Laplacian = f
					local numerator = (u.data[i-1][j] + u.data[i+1][j]) / dx2 + 
						(u.data[i][j-1] + u.data[i][j+1]) / dy2 - f.data[i][j]
					local denominator = 2 / dx2 + 2 / dy2
					
					u.data[i][j] = numerator / denominator
					maxChange = max(maxChange, abs(u.data[i][j] - uOld))
				end
			end
			
			-- Apply boundary conditions
			for i = 1, grid.nx do
				u.data[i][1] = 0  -- Bottom
				u.data[i][grid.ny] = 0  -- Top
			end
			for j = 1, grid.ny do
				u.data[1][j] = 0  -- Left
				u.data[grid.nx][j] = 0  -- Right
			end
			
			if maxChange < tol then
				break
			end
		end
	end
	
	return u
end

--[[============================================================================
	WAVE EQUATION SOLVER
============================================================================]]

--- Solve 1D wave equation (u_tt = c² u_xx)
function PDE.solveWaveEquation1D(config)
	local grid = Grid.new(config.grid or {})
	local c = config.waveSpeed or 1.0
	local dt = config.dt or 0.001
	local tMax = config.tMax or 1.0
	
	-- Need two time levels for wave equation
	local u = grid:clone()  -- Current
	local uPrev = grid:clone()  -- Previous
	local uNext = grid:clone()  -- Next
	
	-- Initial conditions
	if config.initial then
		u:fill(config.initial)
		uPrev:fill(config.initial)
	end
	
	-- Initial velocity (optional)
	if config.initialVelocity then
		local v = grid:clone()
		v:fill(config.initialVelocity)
		-- uPrev = u - dt * v
		for i = 1, grid.nx do
			uPrev.data[i] = u.data[i] - dt * v.data[i]
		end
	end
	
	local dx2 = grid.dx * grid.dx
	local r2 = (c * dt / grid.dx) ^ 2  -- CFL parameter
	
	local t = 0
	local solutions = {}
	local saveInterval = config.saveInterval
	local lastSave = 0
	
	while t < tMax do
		-- Wave equation: u^(n+1) = 2u^n - u^(n-1) + r²(u^n_(i+1) - 2u^n_i + u^n_(i-1))
		for i = 2, grid.nx - 1 do
			uNext.data[i] = 2 * u.data[i] - uPrev.data[i] + 
				r2 * (u.data[i + 1] - 2 * u.data[i] + u.data[i - 1])
		end
		
		-- Boundary conditions (zero for now)
		uNext.data[1] = 0
		uNext.data[grid.nx] = 0
		
		-- Advance time
		uPrev = u:clone()
		u = uNext:clone()
		t = t + dt
		
		if saveInterval and t - lastSave >= saveInterval then
			insert(solutions, {t = t, u = u:clone()})
			lastSave = t
		end
	end
	
	return u, solutions
end

--[[============================================================================
	REACTION-DIFFUSION SYSTEMS
============================================================================]]

--- Solve reaction-diffusion equation
function PDE.solveReactionDiffusion(config)
	local solver = PDE.new(config)
	local u = solver.grid:clone()
	
	if config.initial then
		u:fill(config.initial)
	end
	
	-- Reaction term function
	local reactionFunc = config.reactionFunc or function(u) return 0 end
	
	local tMax = config.tMax or 1.0
	local solutions = {}
	local saveInterval = config.saveInterval
	local lastSave = 0
	
	while solver.t < tMax do
		-- Compute diffusion
		local diffusion = solver:laplacian1D(u)
		
		-- Add reaction term
		local uNew = u:clone()
		if u.dim == 1 then
			for i = 1, u.nx do
				local diff = solver.diffusivity * diffusion.data[i]
				local reaction = reactionFunc(u.data[i])
				uNew.data[i] = u.data[i] + solver.dt * (diff + reaction)
			end
		elseif u.dim == 2 then
			diffusion = solver:laplacian2D(u)
			for i = 1, u.nx do
				for j = 1, u.ny do
					local diff = solver.diffusivity * diffusion.data[i][j]
					local reaction = reactionFunc(u.data[i][j])
					uNew.data[i][j] = u.data[i][j] + solver.dt * (diff + reaction)
				end
			end
		end
		
		solver:applyBC1D(uNew)
		u = uNew
		solver.t = solver.t + solver.dt
		
		if saveInterval and solver.t - lastSave >= saveInterval then
			insert(solutions, {t = solver.t, u = u:clone()})
			lastSave = solver.t
		end
	end
	
	return u, solutions, solver
end

--[[============================================================================
	ANALYSIS AND POST-PROCESSING
============================================================================]]

--- Compute error compared to exact solution
function PDE.computeError(numerical, exact, norm)
	norm = norm or 2
	local error = numerical:clone()
	
	if numerical.dim == 1 then
		for i = 1, numerical.nx do
			local x = numerical:getCoords(i)
			error.data[i] = numerical.data[i] - exact(x)
		end
	elseif numerical.dim == 2 then
		for i = 1, numerical.nx do
			for j = 1, numerical.ny do
				local x, y = numerical:getCoords(i, j)
				error.data[i][j] = numerical.data[i][j] - exact(x, y)
			end
		end
	end
	
	return error:norm(norm)
end

--- Compute conservation properties
function PDE.checkConservation(grid)
	local total = 0
	local count = 0
	
	if grid.dim == 1 then
		for i = 1, grid.nx do
			total = total + grid.data[i] * grid.dx
			count = count + 1
		end
	elseif grid.dim == 2 then
		for i = 1, grid.nx do
			for j = 1, grid.ny do
				total = total + grid.data[i][j] * grid.dx * grid.dy
				count = count + 1
			end
		end
	end
	
	return total
end

--- Export grid to array format for visualization
function PDE.exportToArray(grid)
	local result = {}
	
	if grid.dim == 1 then
		for i = 1, grid.nx do
			local x = grid:getCoords(i)
			insert(result, {x = x, value = grid.data[i]})
		end
	elseif grid.dim == 2 then
		for i = 1, grid.nx do
			for j = 1, grid.ny do
				local x, y = grid:getCoords(i, j)
				insert(result, {x = x, y = y, value = grid.data[i][j]})
			end
		end
	end
	
	return result
end

--[[============================================================================
	UTILITY FUNCTIONS
============================================================================]]

--- Create common initial conditions
PDE.InitialConditions = {
	-- Gaussian pulse
	gaussian = function(amplitude, center, width)
		return function(x)
			return amplitude * exp(-((x - center) / width) ^ 2)
		end
	end,
	
	-- Step function
	step = function(amplitude, position)
		return function(x)
			return x < position and amplitude or 0
		end
	end,
	
	-- Sine wave
	sine = function(amplitude, frequency, phase)
		phase = phase or 0
		return function(x)
			return amplitude * sin(2 * pi * frequency * x + phase)
		end
	end,
	
	-- Top hat function
	topHat = function(amplitude, left, right)
		return function(x)
			return (x >= left and x <= right) and amplitude or 0
		end
	end,
	
	-- 2D Gaussian
	gaussian2D = function(amplitude, centerX, centerY, width)
		return function(x, y)
			local r2 = ((x - centerX) / width) ^ 2 + ((y - centerY) / width) ^ 2
			return amplitude * exp(-r2)
		end
	end,
	
	-- 2D circular step
	circle = function(amplitude, centerX, centerY, radius)
		return function(x, y)
			local r = sqrt((x - centerX) ^ 2 + (y - centerY) ^ 2)
			return r <= radius and amplitude or 0
		end
	end
}

return PDE
