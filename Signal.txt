-- Licensed under MIT License
-- Copyright (c) 2025 Damien Flores

local Signal = {}
Signal.__index = Signal

local sqrt, floor, log, cos, sin, pi = math.sqrt, math.floor, math.log, math.cos, math.sin, math.pi

local function isVector3(v)
	return typeof(v) == "Vector3"
end

-- Complex helpers (represent complex numbers as {re=..., im=...})
local function complexNew(re, im) return { re = re or 0, im = im or 0 } end
local function complexAdd(a, b) return { re = a.re + b.re, im = a.im + b.im } end
local function complexSub(a, b) return { re = a.re - b.re, im = a.im - b.im } end
local function complexMul(a, b)
	return { re = a.re * b.re - a.im * b.im, im = a.re * b.im + a.im * b.re }
end
local function complexScale(a, s) return { re = a.re * s, im = a.im * s } end
local function complexConj(a) return { re = a.re, im = -a.im } end
local function complexAbs2(a) return a.re * a.re + a.im * a.im end
local function complexAbs(a) return sqrt(complexAbs2(a)) end

local function isPowerOfTwo(n) return n > 0 and (n and (n - 1)) == 0 end
local function nextPowerOfTwo(n)
	local p = 1
	while p < n do p = p * 2 end
	return p
end

-- convert real numeric array to complex array
local function realToComplex(arr, n)
	local out = {}
	for i = 1, n do out[i] = complexNew(arr[i] or 0, 0) end
	return out
end

-- recursive Cooley-Tukey FFT (requires n power of two)
local function fftRecursive(buf, n)
	if n == 1 then return { buf[1] } end
	local half = n / 2
	local even, odd = {}, {}
	for i = 1, half do
		even[i] = buf[2 * i - 1]
		odd[i]  = buf[2 * i]
	end
	local Fe = fftRecursive(even, half)
	local Fo = fftRecursive(odd, half)
	local combined = {}
	for k = 0, half - 1 do
		local angle = -2 * pi * k / n
		local tw = complexNew(cos(angle), sin(angle))
		local t = complexMul(tw, Fo[k + 1])
		combined[k + 1] = complexAdd(Fe[k + 1], t)
		combined[k + 1 + half] = complexSub(Fe[k + 1], t)
	end
	return combined
end

-- naive DFT (O(n^2)) fallback
local function dft(buf, n, inverse)
	local sign = inverse and 1 or -1
	local out = {}
	for k = 0, n - 1 do
		local sum = complexNew(0, 0)
		for t = 0, n - 1 do
			local angle = sign * 2 * pi * k * t / n
			local tw = complexNew(cos(angle), sin(angle))
			sum = complexAdd(sum, complexMul(buf[t + 1], tw))
		end
		if inverse then
			out[k + 1] = complexScale(sum, 1 / n)
		else
			out[k + 1] = sum
		end
	end
	return out
end

-- Public FFT: accepts numeric array (real). options: padToPow2 (bool, default true)
function Signal.fft(realSignal, opts)
	opts = opts or {}
	local n = #realSignal
	if n == 0 then return {} end
	local pad = opts.padToPow2
	if pad == nil then pad = true end
	local targetN = n
	if pad and not isPowerOfTwo(n) then targetN = nextPowerOfTwo(n) end
	local buf = {}
	for i = 1, targetN do
		local val = realSignal[i] or 0
		buf[i] = complexNew(val, 0)
	end
	local out
	if isPowerOfTwo(targetN) then
		out = fftRecursive(buf, targetN)
	else
		out = dft(buf, targetN, false)
	end
	return out, targetN
end

-- Public IFFT: accepts complex array, returns real array (length n). opts: trimTo (original length)
function Signal.ifft(freqSignal, opts)
	opts = opts or {}
	local n = #freqSignal
	if n == 0 then return {} end
	-- conjugate, fft, conjugate, scale
	local conjBuf = {}
	for i = 1, n do conjBuf[i] = complexConj(freqSignal[i]) end
	local timeComplex
	if isPowerOfTwo(n) then
		timeComplex = fftRecursive(conjBuf, n)
	else
		timeComplex = dft(conjBuf, n, false)
	end
	local out = {}
	for i = 1, n do
		local c = complexConj(timeComplex[i])
		out[i] = c.re / n
	end
	if opts.trimTo and opts.trimTo < #out then
		for i = opts.trimTo + 1, #out do out[i] = nil end
	end
	return out
end

-- DFT + IDFT explicit
function Signal.dft(realSignal)
	return Signal.fft(realSignal, { padToPow2 = false })
end
function Signal.idft(freqSignal)
	-- produce inverse without additional normalization (ifft handles scaling)
	return Signal.ifft(freqSignal)
end

-- Window functions generator (returns coefficients)
function Signal.windowCoeffs(n, kind)
	kind = (kind or "hann"):lower()
	local coeffs = {}
	if kind == "hann" or kind == "hanning" then
		for i = 1, n do coeffs[i] = 0.5 * (1 - cos(2 * pi * (i - 1) / (n - 1))) end
	elseif kind == "hamming" then
		for i = 1, n do coeffs[i] = 0.54 - 0.46 * cos(2 * pi * (i - 1) / (n - 1)) end
	elseif kind == "blackman" then
		for i = 1, n do
			coeffs[i] = 0.42 - 0.5 * cos(2 * pi * (i - 1) / (n - 1)) + 0.08 * cos(4 * pi * (i - 1) / (n - 1))
		end
	else
		for i = 1, n do coeffs[i] = 1 end
	end
	return coeffs
end

function Signal.applyWindow(signal, coeffs)
	local n = #signal
	local out = {}
	for i = 1, n do out[i] = (signal[i] or 0) * (coeffs[i] or 1) end
	return out
end

-- Power spectrum (magnitudes) from complex frequency bins
function Signal.powerSpectrum(freqBins)
	local n = #freqBins
	local out = {}
	for i = 1, n do out[i] = complexAbs2(freqBins[i]) end
	return out
end

-- Spectral centroid (requires sampleRate and freqBins magnitude array or complex bins)
function Signal.spectralCentroid(freqBins, sampleRate)
	local n = #freqBins
	if n == 0 then return 0 end
	local mags = {}
	if freqBins[1].re ~= nil then -- complex bins
		for i = 1, n do mags[i] = complexAbs(freqBins[i]) end
	else
		mags = freqBins
	end
	local sumMag = 0
	local weighted = 0
	for i = 1, n do
		local freq = (i - 1) * (sampleRate / n)
		local m = mags[i] or 0
		sumMag = sumMag + m
		weighted = weighted + freq * m
	end
	if sumMag == 0 then return 0 end
	return weighted / sumMag
end

-- Root mean square
function Signal.rms(signal)
	local n = #signal
	if n == 0 then return nil end
	if isVector3(signal[1]) then
		local sx, sy, sz = 0, 0, 0
		for i = 1, n do local v = signal[i]; sx = sx + v.X * v.X; sy = sy + v.Y * v.Y; sz = sz + v.Z * v.Z end
		return Vector3.new(sqrt(sx / n), sqrt(sy / n), sqrt(sz / n))
	else
		local s = 0
		for i = 1, n do s = s + (signal[i] or 0) ^ 2 end
		return sqrt(s / n)
	end
end

-- dominant frequency (returns frequency in Hz and bin index)
function Signal.dominantFrequency(freqBins, sampleRate)
	local mags = {}
	local n = #freqBins
	if n == 0 then return 0, 0 end
	if freqBins[1].re ~= nil then
		for i = 1, n do mags[i] = complexAbs(freqBins[i]) end
	else
		mags = freqBins
	end
	local maxIdx, maxVal = 1, mags[1] or 0
	for i = 2, n do
		if mags[i] and mags[i] > maxVal then maxVal, maxIdx = mags[i], i end
	end
	local freq = (maxIdx - 1) * (sampleRate / n)
	return freq, maxIdx
end

-- convolution (uses FFT when size large)
local function naiveConvolve(a, b)
	local na, nb = #a, #b
	local out = {}
	for i = 1, na + nb - 1 do out[i] = 0 end
	for i = 1, na do
		for j = 1, nb do
			out[i + j - 1] = out[i + j - 1] + (a[i] or 0) * (b[j] or 0)
		end
	end
	return out
end

local function fftConvolve(a, b)
	local na, nb = #a, #b
	local n = nextPowerOfTwo(na + nb - 1)
	local padA = {}
	local padB = {}
	for i = 1, n do padA[i] = complexNew(a[i] or 0, 0); padB[i] = complexNew(b[i] or 0, 0) end
	local Fa = (isPowerOfTwo(n) and fftRecursive(padA, n)) or dft(padA, n, false)
	local Fb = (isPowerOfTwo(n) and fftRecursive(padB, n)) or dft(padB, n, false)
	local Fc = {}
	for i = 1, n do Fc[i] = complexMul(Fa[i], Fb[i]) end
	local result = Signal.ifft(Fc, { trimTo = na + nb - 1 })
	return result
end

function Signal.convolve(a, b)
	local na, nb = #a, #b
	if na == 0 or nb == 0 then return {} end
	if na * nb > 4096 then
		return fftConvolve(a, b)
	else
		return naiveConvolve(a, b)
	end
end

-- cross-correlation a â‹† b  (lag from -(nb-1) to na-1) -> returns numeric array, index shift = nb
function Signal.crossCorrelate(a, b)
	local na, nb = #a, #b
	if na == 0 or nb == 0 then return {} end
	local out = {}
	for lag = -(nb - 1), na - 1 do
		local sum = 0
		for i = 1, nb do
			local j = i + lag
			if j >= 1 and j <= na then
				sum = sum + a[j] * b[i]
			end
		end
		out[#out + 1] = sum
	end
	return out
end

-- autocorrelation (returns lags 0..n-1)
function Signal.autocorrelate(a)
	local n = #a
	if n == 0 then return {} end
	local out = {}
	for lag = 0, n - 1 do
		local sum = 0
		for i = 1, n - lag do sum = sum + a[i] * a[i + lag] end
		out[lag + 1] = sum
	end
	return out
end

-- frequency-domain filtering: maskFn(binIndex, freq, complexBin) -> complexMultiplier (complex or scalar)
-- returns filtered real signal (length originalLength)
function Signal.freqFilter(realSignal, sampleRate, maskFn, opts)
	opts = opts or {}
	local nOrig = #realSignal
	local freqBins, n = Signal.fft(realSignal, { padToPow2 = opts.padToPow2 ~= false })
	for k = 1, n do
		local freq = (k - 1) * (sampleRate / n)
		local mul = maskFn(k, freq, freqBins[k])
		if mul == nil then mul = 1 end
		if type(mul) == "number" then
			freqBins[k] = complexScale(freqBins[k], mul)
		else
			freqBins[k] = complexMul(freqBins[k], mul)
		end
	end
	local filtered = Signal.ifft(freqBins, { trimTo = nOrig })
	return filtered
end

-- Helpers: process Vector3 time-series by component
local function splitVectorSeries(series)
	local n = #series
	local xs, ys, zs = {}, {}, {}
	for i = 1, n do
		local v = series[i]
		xs[i], ys[i], zs[i] = v.X, v.Y, v.Z
	end
	return xs, ys, zs
end

local function combineThree(a, b, c)
	local n = math.max(#a, #b, #c)
	local out = {}
	for i = 1, n do out[i] = Vector3.new(a[i] or 0, b[i] or 0, c[i] or 0) end
	return out
end

-- Vector-aware wrappers
function Signal.fftVector(series, opts)
	local xs, ys, zs = splitVectorSeries(series)
	local fx, nx = Signal.fft(xs, opts)
	local fy, ny = Signal.fft(ys, opts)
	local fz, nz = Signal.fft(zs, opts)
	return { X = fx, Y = fy, Z = fz }, nx
end

function Signal.ifftVector(freqObj, origLen)
	local rx = Signal.ifft(freqObj.X, { trimTo = origLen })
	local ry = Signal.ifft(freqObj.Y, { trimTo = origLen })
	local rz = Signal.ifft(freqObj.Z, { trimTo = origLen })
	return combineThree(rx, ry, rz)
end

function Signal.powerSpectrumVector(freqObj)
	return {
		X = Signal.powerSpectrum(freqObj.X),
		Y = Signal.powerSpectrum(freqObj.Y),
		Z = Signal.powerSpectrum(freqObj.Z)
	}
end

-- Convenience: compute dominant frequency per-component for Vector3 series
function Signal.dominantFrequencyVector(freqObj, sampleRate)
	local fx, fy, fz = Signal.dominantFrequency(freqObj.X, sampleRate), Signal.dominantFrequency(freqObj.Y, sampleRate), Signal.dominantFrequency(freqObj.Z, sampleRate)
	return { X = fx, Y = fy, Z = fz }
end

-- Utilities: window + fft pipeline
function Signal.spectralAnalysis(signal, sampleRate, opts)
	-- returns { freqBins = ..., power = ..., centroid = ..., dominant = {...} }
	opts = opts or {}
	if #signal == 0 then return nil end
	if isVector3(signal[1]) then
		local freqObj, n = Signal.fftVector(signal, { padToPow2 = opts.padToPow2 })
		local power = Signal.powerSpectrumVector(freqObj)
		return {
			freq = freqObj,
			power = power,
			centroid = {
				X = Signal.spectralCentroid(power.X, sampleRate),
				Y = Signal.spectralCentroid(power.Y, sampleRate),
				Z = Signal.spectralCentroid(power.Z, sampleRate)
			},
			dominant = Signal.dominantFrequencyVector(freqObj, sampleRate),
			_n = n
		}
	else
		local bins, n = Signal.fft(signal, { padToPow2 = opts.padToPow2 })
		local power = Signal.powerSpectrum(bins)
		return {
			freq = bins,
			power = power,
			centroid = Signal.spectralCentroid(power, sampleRate),
			dominant = { Signal.dominantFrequency(bins, sampleRate) },
			_n = n
		}
	end
end

return Signal
