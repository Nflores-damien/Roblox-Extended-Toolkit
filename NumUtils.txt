-- Licensed under MIT License
-- Copyright (c) 2025 Damien Flores

local NumUtils = {}
NumUtils.__index = NumUtils

NumUtils.TAU = 6.2831853071795864769252867665590057683943387987502116419498891846
NumUtils.E   = 2.7182818284590452353602874713526624977572470936999595749669676277
NumUtils.PHI = 1.6180339887498948482045868343656381177203091798057628621354486227
NumUtils.SQRT2 = 1.41421356237309504880168872420969807856967187537694807317667973799
NumUtils.LOG2 = 0.69314718055994530941723212145817656807550013436025525412068000949
NumUtils.LOG10 = 2.30258509299404568401799145468436420760110148862877297603332790181
NumUtils.PI = NumUtils.TAU / 2
NumUtils.SQRT3 = 1.73205080756887729352744634150587236694280525381038062805580697945

local sqrt, abs, floor, max, min, exp, log, type = math.sqrt, math.abs, math.floor, math.max, math.min, math.exp, math.log, type

local function isVector3(v) return typeof and typeof(v) == "Vector3" end

function NumUtils.clamp(x, a, b)
	if isVector3(x) then
		return Vector3.new(
			math.clamp(x.X, a.X, b.X),
			math.clamp(x.Y, a.Y, b.Y),
			math.clamp(x.Z, a.Z, b.Z)
		)
	else
		return (x < a) and a or ((x > b) and b or x)
	end
end

function NumUtils.lerp(a, b, t)
	if isVector3(a) and isVector3(b) then
		return a + (b - a) * t
	else
		return a + (b - a) * t
	end
end

function NumUtils.wrap(x, low, high)
	if isVector3(x) then
		local lx, hx = low.X, high.X
		local ly, hy = low.Y, high.Y
		local lz, hz = low.Z, high.Z
		local function wrap1(v, l, h)
			local len = h - l
			if len == 0 then return l end
			local m = (v - l) % len
			if m < 0 then m = m + len end
			return l + m
		end
		return Vector3.new(wrap1(x.X, lx, hx), wrap1(x.Y, ly, hy), wrap1(x.Z, lz, hz))
	else
		local len = high - low
		if len == 0 then return low end
		local m = (x - low) % len
		if m < 0 then m = m + len end
		return low + m
	end
end

function NumUtils.sign(x)
	if isVector3(x) then
		local function s(v) if v > 0 then return 1 elseif v < 0 then return -1 else return 0 end end
		return Vector3.new(s(x.X), s(x.Y), s(x.Z))
	else
		if x > 0 then return 1 elseif x < 0 then return -1 else return 0 end
	end
end

function NumUtils.round(x, decimals)
	decimals = decimals or 0
	local mult = 10 ^ decimals
	if isVector3(x) then
		return Vector3.new(
			math.floor(x.X * mult + 0.5) / mult,
			math.floor(x.Y * mult + 0.5) / mult,
			math.floor(x.Z * mult + 0.5) / mult
		)
	else
		return math.floor(x * mult + 0.5) / mult
	end
end

function NumUtils.deg2rad(d) return d * (NumUtils.PI / 180) end
function NumUtils.rad2deg(r) return r * (180 / NumUtils.PI) end

function NumUtils.logBase(x, base)
	if isVector3(x) then
		return Vector3.new(
			math.log(x.X, base),
			math.log(x.Y, base),
			math.log(x.Z, base)
		)
	else
		if base == nil then return math.log(x) end
		return math.log(x) / math.log(base)
	end
end

-- Hyperbolic functions
function NumUtils.sinh(x)
	if isVector3(x) then
		return Vector3.new(NumUtils.sinh(x.X), NumUtils.sinh(x.Y), NumUtils.sinh(x.Z))
	else
		local ex = exp(x)
		local enx = exp(-x)
		return (ex - enx) * 0.5
	end
end

function NumUtils.cosh(x)
	if isVector3(x) then
		return Vector3.new(NumUtils.cosh(x.X), NumUtils.cosh(x.Y), NumUtils.cosh(x.Z))
	else
		local ex = exp(x)
		local enx = exp(-x)
		return (ex + enx) * 0.5
	end
end

function NumUtils.tanh(x)
	if isVector3(x) then
		return Vector3.new(NumUtils.tanh(x.X), NumUtils.tanh(x.Y), NumUtils.tanh(x.Z))
	else
		local ex = exp(x)
		local enx = exp(-x)
		return (ex - enx) / (ex + enx)
	end
end

function NumUtils.asinh(x)
	if isVector3(x) then
		return Vector3.new(NumUtils.asinh(x.X), NumUtils.asinh(x.Y), NumUtils.asinh(x.Z))
	else
		return log(x + sqrt(x * x + 1))
	end
end

function NumUtils.acosh(x)
	if isVector3(x) then
		return Vector3.new(NumUtils.acosh(x.X), NumUtils.acosh(x.Y), NumUtils.acosh(x.Z))
	else
		return log(x + sqrt(x * x - 1))
	end
end

function NumUtils.atanh(x)
	if isVector3(x) then
		return Vector3.new(NumUtils.atanh(x.X), NumUtils.atanh(x.Y), NumUtils.atanh(x.Z))
	else
		return 0.5 * log((1 + x) / (1 - x))
	end
end

-- Remap and smoothing
function NumUtils.remap(value, inMin, inMax, outMin, outMax, doClamp)
	if isVector3(value) then
		return Vector3.new(
			NumUtils.remap(value.X, inMin.X, inMax.X, outMin.X, outMax.X, doClamp),
			NumUtils.remap(value.Y, inMin.Y, inMax.Y, outMin.Y, outMax.Y, doClamp),
			NumUtils.remap(value.Z, inMin.Z, inMax.Z, outMin.Z, outMax.Z, doClamp)
		)
	else
		local t = (value - inMin) / (inMax - inMin)
		local out = outMin + t * (outMax - outMin)
		if doClamp then
			if outMax >= outMin then
				return NumUtils.clamp(out, outMin, outMax)
			else
				return NumUtils.clamp(out, outMax, outMin)
			end
		end
		return out
	end
end

function NumUtils.smoothstep(x, edge0, edge1)
	edge0 = edge0 or 0
	edge1 = edge1 or 1
	local t = NumUtils.clamp((x - edge0) / (edge1 - edge0), 0, 1)
	return t * t * (3 - 2 * t)
end

function NumUtils.smootherstep(x, edge0, edge1)
	edge0 = edge0 or 0
	edge1 = edge1 or 1
	local t = NumUtils.clamp((x - edge0) / (edge1 - edge0), 0, 1)
	return t * t * t * (t * (t * 6 - 15) + 10)
end

function NumUtils.approxEqual(a, b, rel_tol, abs_tol)
	rel_tol = rel_tol or 1e-09
	abs_tol = abs_tol or 0.0
	if isVector3(a) and isVector3(b) then
		local dx = abs(a.X - b.X); local dy = abs(a.Y - b.Y); local dz = abs(a.Z - b.Z)
		return dx <= max(abs_tol, rel_tol * max(abs(a.X), abs(b.X)))
			and dy <= max(abs_tol, rel_tol * max(abs(a.Y), abs(b.Y)))
			and dz <= max(abs_tol, rel_tol * max(abs(a.Z), abs(b.Z)))
	else
		return abs(a - b) <= max(abs_tol, rel_tol * max(abs(a), abs(b)))
	end
end

function NumUtils.mapRange(x, inMin, inMax, outMin, outMax, doClamp)
	return NumUtils.remap(x, inMin, inMax, outMin, outMax, doClamp)
end

function NumUtils.snapToGrid(x, step)
	if isVector3(x) then
		return Vector3.new(
			floor((x.X + step * 0.5) / step) * step,
			floor((x.Y + step * 0.5) / step) * step,
			floor((x.Z + step * 0.5) / step) * step
		)
	else
		return floor((x + step * 0.5) / step) * step
	end
end

return NumUtils
