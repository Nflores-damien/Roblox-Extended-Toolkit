-- Licensed under MIT License
-- Copyright (c) 2025 Damien Flores

local Filters = {}
Filters.__index = Filters

local function cw(a, b, fn)
	if typeof(a) == "Vector3" then
		return Vector3.new(fn(a.X,b.X), fn(a.Y,b.Y), fn(a.Z,b.Z))
	else
		return fn(a,b)
	end
end

function Filters.new()
	return setmetatable({
		histories = {}
	}, Filters)
end

function Filters:add(name, value)
	self.histories[name] = self.histories[name] or {}
	table.insert(self.histories[name], value)
end

function Filters:getHistory(name)
	return self.histories[name] or {}
end

function Filters:movingAverage(name, window)
	local history = self:getHistory(name)
	local n = #history
	if n == 0 then return nil end
	window = math.min(window or n, n)
	local sum = history[n-window+1]
	for i = n-window+2, n do
		sum = cw(sum, history[i], function(x,y) return x+y end)
	end
	return cw(sum, window, function(x,y) return x/y end)
end

function Filters:EMA(name, alpha)
	local history = self:getHistory(name)
	local n = #history
	if n == 0 then return nil end
	alpha = alpha or 0.1
	local prev = history[1]
	for i=2,n do
		prev = cw(prev, history[i], function(p,c) return p*(1-alpha)+c*alpha end)
	end
	return prev
end

function Filters:median(name, window)
	local history = self:getHistory(name)
	local n = #history
	if n == 0 then return nil end
	window = math.min(window or n, n)
	local t = {}
	for i = n-window+1, n do t[#t+1] = history[i] end
	if typeof(t[1]) == "Vector3" then
		local xs, ys, zs = {}, {}, {}
		for i,v in ipairs(t) do xs[i], ys[i], zs[i] = v.X,v.Y,v.Z end
		table.sort(xs); table.sort(ys); table.sort(zs)
		local mid = math.ceil(#t/2)
		return Vector3.new(xs[mid], ys[mid], zs[mid])
	else
		table.sort(t)
		return t[math.ceil(#t/2)]
	end
end

function Filters:savitzkyGolay(name, coeffs)
	local history = self:getHistory(name)
	local n = #history
	local k = #coeffs
	if n < k then return nil end
	local sum
	if typeof(history[n]) == "Vector3" then
		sum = Vector3.new(0,0,0)
		for i=1,k do sum += history[n-k+i]*coeffs[i] end
	else
		sum = 0
		for i=1,k do sum += history[n-k+i]*coeffs[i] end
	end
	local divisor = 0
	for _,c in ipairs(coeffs) do divisor = divisor + c end
	return cw(sum, divisor, function(x,y) return x/y end)
end

function Filters:highPass(name, alpha)
	local history = self:getHistory(name)
	local n = #history
	if n < 2 then return nil end
	alpha = alpha or 0.1
	return cw(history[n-1], history[n], function(p,c) return alpha*(p+c-p) end)
end

function Filters:bandPass(name, lowAlpha, highAlpha)
	local hp = self:highPass(name, highAlpha)
	if not hp then return nil end
	return cw(self:getHistory(name)[#self:getHistory(name)-1] or hp, hp, function(p,c) return p*(1-lowAlpha)+c*lowAlpha end)
end

return Filters