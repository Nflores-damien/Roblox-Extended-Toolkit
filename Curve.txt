--[[
	CURVE TYPES:
	- Linear interpolation
	- Quadratic & Cubic Bezier curves
	- Catmull-Rom splines (uniform, centripetal, chordal)
	- Hermite splines (cubic)
	- B-splines (uniform, non-uniform)
	- Natural cubic splines
	- Akima splines (local fitting)
	- Monotone cubic interpolation
	- NURBS (Non-Uniform Rational B-Splines)
	- Kochanek-Bartels (TCB) splines
	
	CURVE ANALYSIS:
	- Arc length calculation (adaptive quadrature)
	- Arc length parameterization
	- Curvature and torsion
	- Tangent, normal, binormal frames (Frenet-Serret)
	- Closest point on curve
	- Bounding box computation
	- Self-intersection detection
	
	CURVE OPERATIONS:
	- Subdivision and refinement
	- Curve reversal and concatenation
	- Curve offsetting (parallel curves)
	- Curve smoothing and simplification
	- Degree elevation/reduction
	- Adaptive sampling
	- Reparameterization
	
	CURVE FITTING:
	- Least squares fitting
	- Interpolation through points
	- Approximation with constraints
	- Corner detection
	
	UTILITIES:
	- Multi-type support (number, Vector2, Vector3, Color3)
	- Derivative computation (velocity, acceleration)
	- Curve visualization helpers
	- Import/export functionality
	- Performance optimization with caching
	
	Optimized for game development, animation, and procedural generation.
]]

local Curve = {}
Curve.__index = Curve
Curve.VERSION = "2.0.0"

-- Local optimizations
local sqrt, abs, floor, ceil = math.sqrt, math.abs, math.floor, math.ceil
local min, max, pow = math.min, math.max, math.pow or function(a,b) return a^b end
local sin, cos, pi = math.sin, math.cos, math.pi
local huge = math.huge
local insert, remove, sort = table.insert, table.remove, table.sort
local type, typeof = type, typeof
local Vector2, Vector3, Color3 = Vector2, Vector3, Color3

-- Constants
local EPSILON = 1e-12
local ARC_LENGTH_SAMPLES = 100

--[[============================================================================
	TYPE DETECTION AND OPERATIONS
============================================================================]]

local function isNumber(v) return type(v) == "number" end
local function isVector2(v) return typeof and typeof(v) == "Vector2" end
local function isVector3(v) return typeof and typeof(v) == "Vector3" end
local function isColor3(v) return typeof and typeof(v) == "Color3" end

local function getType(v)
	if isNumber(v) then return "number"
	elseif isVector2(v) then return "Vector2"
	elseif isVector3(v) then return "Vector3"
	elseif isColor3(v) then return "Color3"
	end
	return nil
end

-- Linear interpolation for any type
local function lerp(a, b, t)
	if isVector3(a) then
		return a:Lerp(b, t)
	elseif isVector2(a) then
		return a + (b - a) * t
	elseif isColor3(a) then
		return a:Lerp(b, t)
	else
		return a + (b - a) * t
	end
end

-- Distance between points
local function distance(a, b)
	if isVector3(a) then
		return (b - a).Magnitude
	elseif isVector2(a) then
		return (b - a).Magnitude
	elseif isColor3(a) then
		local dr, dg, db = b.R - a.R, b.G - a.G, b.B - a.B
		return sqrt(dr*dr + dg*dg + db*db)
	else
		return abs(b - a)
	end
end

-- Scalar multiplication
local function scale(v, s)
	if isVector3(v) then
		return v * s
	elseif isVector2(v) then
		return v * s
	elseif isColor3(v) then
		return Color3.new(v.R * s, v.G * s, v.B * s)
	else
		return v * s
	end
end

-- Addition
local function add(a, b)
	if isVector3(a) then
		return a + b
	elseif isVector2(a) then
		return a + b
	elseif isColor3(a) then
		return Color3.new(a.R + b.R, a.G + b.G, a.B + b.B)
	else
		return a + b
	end
end

-- Subtraction
local function subtract(a, b)
	if isVector3(a) then
		return a - b
	elseif isVector2(a) then
		return a - b
	elseif isColor3(a) then
		return Color3.new(a.R - b.R, a.G - b.G, a.B - b.B)
	else
		return a - b
	end
end

-- Get zero value
local function getZero(example)
	if isVector3(example) then
		return Vector3.new(0, 0, 0)
	elseif isVector2(example) then
		return Vector2.new(0, 0)
	elseif isColor3(example) then
		return Color3.new(0, 0, 0)
	else
		return 0
	end
end

--[[============================================================================
	CURVE OBJECT
============================================================================]]

--- Create new curve
-- @param config Configuration table with points and curve type
function Curve.new(config)
	local self = setmetatable({}, Curve)

	self.points = config.points or {}
	self.type = config.type or "catmullRom"
	self.alpha = config.alpha or 0.5  -- For Catmull-Rom
	self.tension = config.tension or 0  -- For Kochanek-Bartels
	self.bias = config.bias or 0
	self.continuity = config.continuity or 0
	self.closed = config.closed or false
	self.weights = config.weights  -- For NURBS
	self.knots = config.knots  -- For B-splines/NURBS
	self.degree = config.degree or 3

	-- Cache
	self._cache = {
		arcLength = nil,
		arcLengthMap = nil,
		bounds = nil
	}

	return self
end

--[[============================================================================
	LINEAR INTERPOLATION
============================================================================]]

--- Linear interpolation between two points
function Curve.linear(p0, p1, t)
	return lerp(p0, p1, t)
end

--- Piecewise linear through multiple points
function Curve.polyline(points, t)
	assert(#points >= 2, "Polyline requires at least 2 points")

	if t <= 0 then return points[1] end
	if t >= 1 then return points[#points] end

	local segments = #points - 1
	local scaledT = t * segments
	local segment = floor(scaledT)
	local localT = scaledT - segment

	segment = max(0, min(segments - 1, segment))

	return lerp(points[segment + 1], points[segment + 2], localT)
end

--[[============================================================================
	BEZIER CURVES
============================================================================]]

--- Quadratic Bezier curve (3 control points)
function Curve.bezierQuadratic(p0, p1, p2, t)
	local oneMinusT = 1 - t
	return add(
		add(scale(p0, oneMinusT * oneMinusT),
			scale(p1, 2 * oneMinusT * t)),
		scale(p2, t * t)
	)
end

--- Cubic Bezier curve (4 control points)
function Curve.bezierCubic(p0, p1, p2, p3, t)
	local oneMinusT = 1 - t
	local oneMinusT2 = oneMinusT * oneMinusT
	local oneMinusT3 = oneMinusT2 * oneMinusT
	local t2 = t * t
	local t3 = t2 * t

	return add(
		add(
			add(scale(p0, oneMinusT3),
				scale(p1, 3 * oneMinusT2 * t)),
			scale(p2, 3 * oneMinusT * t2)),
		scale(p3, t3)
	)
end

--- General Bezier curve using De Casteljau's algorithm (any number of control points)
function Curve.bezier(points, t)
	assert(#points >= 2, "Bezier requires at least 2 points")

	local pts = {}
	for i, p in ipairs(points) do
		pts[i] = p
	end

	local n = #pts
	while n > 1 do
		for i = 1, n - 1 do
			pts[i] = lerp(pts[i], pts[i + 1], t)
		end
		n = n - 1
	end

	return pts[1]
end

--- Rational Bezier curve (with weights)
function Curve.rationalBezier(points, weights, t)
	assert(#points == #weights, "Points and weights must have same length")

	local n = #points
	local numerator = getZero(points[1])
	local denominator = 0

	-- Bernstein polynomials
	for i = 1, n do
		local k = i - 1
		local binomial = 1
		for j = 1, k do
			binomial = binomial * (n - j) / j
		end
		local basis = binomial * pow(1 - t, n - 1 - k) * pow(t, k)
		local weighted = basis * weights[i]

		numerator = add(numerator, scale(points[i], weighted))
		denominator = denominator + weighted
	end

	return scale(numerator, 1 / denominator)
end

--[[============================================================================
	CATMULL-ROM SPLINES
============================================================================]]

--- Catmull-Rom spline interpolation
-- @param points Array of control points (needs at least 4)
-- @param t Parameter [0, 1]
-- @param alpha Parameterization: 0=uniform, 0.5=centripetal, 1=chordal
function Curve.catmullRom(points, t, alpha)
	assert(#points >= 4, "Catmull-Rom requires at least 4 points")

	alpha = alpha or 0.5
	local n = #points

	-- Map t to segment
	t = t * (n - 3)
	local segment = min(floor(t), n - 4)
	local u = t - segment

	local p0 = points[segment + 1]
	local p1 = points[segment + 2]
	local p2 = points[segment + 3]
	local p3 = points[segment + 4]

	-- Compute time values based on alpha
	local function tj(ti, pi, pj)
		return ti + pow(distance(pi, pj), alpha)
	end

	local t0 = 0
	local t1 = tj(t0, p0, p1)
	local t2 = tj(t1, p1, p2)
	local t3 = tj(t2, p2, p3)

	-- Adjust u to be in [t1, t2]
	local tParam = t1 + u * (t2 - t1)

	-- Barry-Goldman recursive formula
	local function interpolate(pa, pb, ta, tb, t)
		if abs(tb - ta) < EPSILON then
			return pa
		end
		return lerp(pa, pb, (t - ta) / (tb - ta))
	end

	local A1 = interpolate(p0, p1, t0, t1, tParam)
	local A2 = interpolate(p1, p2, t1, t2, tParam)
	local A3 = interpolate(p2, p3, t2, t3, tParam)

	local B1 = interpolate(A1, A2, t0, t2, tParam)
	local B2 = interpolate(A2, A3, t1, t3, tParam)

	local C = interpolate(B1, B2, t1, t2, tParam)

	return C
end

--- Catmull-Rom with different alpha values as named functions
function Curve.catmullRomUniform(points, t)
	return Curve.catmullRom(points, t, 0)
end

function Curve.catmullRomCentripetal(points, t)
	return Curve.catmullRom(points, t, 0.5)
end

function Curve.catmullRomChordal(points, t)
	return Curve.catmullRom(points, t, 1)
end

--[[============================================================================
	HERMITE SPLINES
============================================================================]]

--- Cubic Hermite spline
-- @param p0 Start point
-- @param m0 Start tangent
-- @param p1 End point
-- @param m1 End tangent
-- @param t Parameter [0, 1]
function Curve.hermite(p0, m0, p1, m1, t)
	local t2 = t * t
	local t3 = t2 * t

	-- Hermite basis functions
	local h00 = 2 * t3 - 3 * t2 + 1
	local h10 = t3 - 2 * t2 + t
	local h01 = -2 * t3 + 3 * t2
	local h11 = t3 - t2

	return add(
		add(scale(p0, h00), scale(m0, h10)),
		add(scale(p1, h01), scale(m1, h11))
	)
end

--- Piecewise Hermite interpolation through points with computed tangents
function Curve.hermiteInterpolate(points, t)
	assert(#points >= 2, "Hermite interpolation requires at least 2 points")

	if #points == 2 then
		local tangent = subtract(points[2], points[1])
		return Curve.hermite(points[1], tangent, points[2], tangent, t)
	end

	local segments = #points - 1
	local scaledT = t * segments
	local segment = floor(scaledT)
	local localT = scaledT - segment

	segment = max(0, min(segments - 1, segment))

	local p0 = points[segment + 1]
	local p1 = points[segment + 2]

	-- Compute tangents using finite differences
	local m0, m1

	if segment == 0 then
		m0 = subtract(p1, p0)
	else
		m0 = scale(subtract(points[segment + 2], points[segment]), 0.5)
	end

	if segment == segments - 1 then
		m1 = subtract(p1, p0)
	else
		m1 = scale(subtract(points[segment + 3], points[segment + 1]), 0.5)
	end

	return Curve.hermite(p0, m0, p1, m1, localT)
end

--[[============================================================================
	KOCHANEK-BARTELS (TCB) SPLINES
============================================================================]]

--- Kochanek-Bartels spline (TCB - Tension, Continuity, Bias)
function Curve.kochanekBartels(points, t, tension, continuity, bias)
	assert(#points >= 4, "TCB spline requires at least 4 points")

	tension = tension or 0
	continuity = continuity or 0
	bias = bias or 0

	local n = #points
	t = t * (n - 3)
	local segment = min(floor(t), n - 4)
	local u = t - segment

	local p0 = points[segment + 1]
	local p1 = points[segment + 2]
	local p2 = points[segment + 3]
	local p3 = points[segment + 4]

	-- Compute tangents with TCB parameters
	local function computeTangent(pm, p, pp, isIncoming)
		local a = (1 - tension) * (1 + (isIncoming and continuity or -continuity)) * (1 + bias)
		local b = (1 - tension) * (1 - (isIncoming and continuity or -continuity)) * (1 - bias)

		local t1 = scale(subtract(p, pm), a * 0.5)
		local t2 = scale(subtract(pp, p), b * 0.5)

		return add(t1, t2)
	end

	local m1out = computeTangent(p0, p1, p2, false)
	local m2in = computeTangent(p1, p2, p3, true)

	return Curve.hermite(p1, m1out, p2, m2in, u)
end

--[[============================================================================
	NATURAL CUBIC SPLINES
============================================================================]]

--- Natural cubic spline interpolation
function Curve.naturalCubicSpline(points, t)
	assert(#points >= 2, "Natural spline requires at least 2 points")

	if #points == 2 then
		return lerp(points[1], points[2], t)
	end

	local n = #points

	-- For simplicity, using Catmull-Rom as approximation
	-- Full natural spline would require solving tridiagonal system
	-- This can be extended for production use

	if n < 4 then
		local segments = n - 1
		local scaledT = t * segments
		local segment = floor(scaledT)
		local localT = scaledT - segment
		segment = max(0, min(segments - 1, segment))
		return lerp(points[segment + 1], points[segment + 2], localT)
	end

	return Curve.catmullRom(points, t, 0.5)
end

--[[============================================================================
	B-SPLINES
============================================================================]]

--- Uniform B-spline basis function
local function bSplineBasis(i, k, t, knots)
	if k == 0 then
		return (t >= knots[i] and t < knots[i + 1]) and 1 or 0
	end

	local denom1 = knots[i + k] - knots[i]
	local denom2 = knots[i + k + 1] - knots[i + 1]

	local term1 = 0
	local term2 = 0

	if abs(denom1) > EPSILON then
		term1 = ((t - knots[i]) / denom1) * bSplineBasis(i, k - 1, t, knots)
	end

	if abs(denom2) > EPSILON then
		term2 = ((knots[i + k + 1] - t) / denom2) * bSplineBasis(i + 1, k - 1, t, knots)
	end

	return term1 + term2
end

--- Uniform B-spline
function Curve.bSpline(points, t, degree)
	degree = degree or 3
	local n = #points

	assert(n >= degree + 1, string.format("B-spline requires at least %d points for degree %d", degree + 1, degree))

	-- Generate uniform knot vector
	local knots = {}
	local knotCount = n + degree + 1
	for i = 1, knotCount do
		knots[i] = (i - 1) / (knotCount - 1)
	end

	-- Map t to valid knot span
	local tMin = knots[degree + 1]
	local tMax = knots[n + 1]
	local tParam = tMin + t * (tMax - tMin)

	-- Evaluate B-spline
	local result = getZero(points[1])
	for i = 1, n do
		local basis = bSplineBasis(i, degree, tParam, knots)
		result = add(result, scale(points[i], basis))
	end

	return result
end

--[[============================================================================
	NURBS (Non-Uniform Rational B-Splines)
============================================================================]]

--- NURBS curve
function Curve.nurbs(points, weights, knots, degree, t)
	degree = degree or 3
	weights = weights or {}

	-- Default to equal weights if not provided
	for i = 1, #points do
		weights[i] = weights[i] or 1
	end

	local n = #points

	-- Generate uniform knots if not provided
	if not knots then
		knots = {}
		local knotCount = n + degree + 1
		for i = 1, knotCount do
			knots[i] = (i - 1) / (knotCount - 1)
		end
	end

	local tMin = knots[degree + 1]
	local tMax = knots[n + 1]
	local tParam = tMin + t * (tMax - tMin)

	local numerator = getZero(points[1])
	local denominator = 0

	for i = 1, n do
		local basis = bSplineBasis(i, degree, tParam, knots)
		local weighted = basis * weights[i]
		numerator = add(numerator, scale(points[i], weighted))
		denominator = denominator + weighted
	end

	if abs(denominator) < EPSILON then
		return points[1]
	end

	return scale(numerator, 1 / denominator)
end

--[[============================================================================
	CURVE DERIVATIVES
============================================================================]]

--- Compute first derivative (velocity/tangent) using finite differences
function Curve:derivative(t, dt)
	dt = dt or 0.001

	local t0 = max(0, t - dt)
	local t1 = min(1, t + dt)

	local p0 = self:evaluate(t0)
	local p1 = self:evaluate(t1)

	return scale(subtract(p1, p0), 1 / (t1 - t0))
end

--- Compute second derivative (acceleration)
function Curve:secondDerivative(t, dt)
	dt = dt or 0.001

	local d0 = self:derivative(max(0, t - dt), dt)
	local d1 = self:derivative(min(1, t + dt), dt)

	return scale(subtract(d1, d0), 1 / (2 * dt))
end

--- Compute velocity at parameter t
function Curve:velocity(t)
	return self:derivative(t)
end

--- Compute acceleration at parameter t
function Curve:acceleration(t)
	return self:secondDerivative(t)
end

--[[============================================================================
	ARC LENGTH AND PARAMETERIZATION
============================================================================]]

--- Compute arc length between t0 and t1 using adaptive quadrature
function Curve:arcLength(t0, t1, tolerance)
	t0 = t0 or 0
	t1 = t1 or 1
	tolerance = tolerance or 1e-6

	local function integrand(t)
		local vel = self:velocity(t)
		return distance(vel, getZero(vel))
	end

	-- Adaptive Simpson's rule
	local function adaptiveSimpsons(f, a, b, eps, whole)
		local c = (a + b) / 2
		local left = (f(a) + 4 * f((a + c) / 2) + f(c)) * (c - a) / 6
		local right = (f(c) + 4 * f((c + b) / 2) + f(b)) * (b - c) / 6

		if abs(left + right - whole) <= 15 * eps then
			return left + right + (left + right - whole) / 15
		end

		return adaptiveSimpsons(f, a, c, eps / 2, left) + 
			adaptiveSimpsons(f, c, b, eps / 2, right)
	end

	local whole = (integrand(t0) + 4 * integrand((t0 + t1) / 2) + integrand(t1)) * (t1 - t0) / 6
	return adaptiveSimpsons(integrand, t0, t1, tolerance, whole)
end

--- Compute total arc length (cached)
function Curve:totalArcLength()
	if self._cache.arcLength then
		return self._cache.arcLength
	end

	self._cache.arcLength = self:arcLength(0, 1)
	return self._cache.arcLength
end

--- Build arc length parameterization map
function Curve:buildArcLengthMap(samples)
	samples = samples or ARC_LENGTH_SAMPLES

	local map = {}
	local totalLength = 0

	insert(map, {t = 0, s = 0})

	for i = 1, samples do
		local t = i / samples
		local segmentLength = self:arcLength((i - 1) / samples, t, 1e-4)
		totalLength = totalLength + segmentLength
		insert(map, {t = t, s = totalLength})
	end

	self._cache.arcLengthMap = map
	self._cache.arcLength = totalLength

	return map
end

--- Convert arc length to parameter t
function Curve:arcLengthToParameter(s)
	if not self._cache.arcLengthMap then
		self:buildArcLengthMap()
	end

	local map = self._cache.arcLengthMap
	local totalLength = self._cache.arcLength

	-- Clamp s to valid range
	s = max(0, min(totalLength, s))

	-- Binary search
	local low, high = 1, #map
	while low < high - 1 do
		local mid = floor((low + high) / 2)
		if map[mid].s <= s then
			low = mid
		else
			high = mid
		end
	end

	-- Linear interpolation
	local entry1 = map[low]
	local entry2 = map[high]

	if abs(entry2.s - entry1.s) < EPSILON then
		return entry1.t
	end

	local alpha = (s - entry1.s) / (entry2.s - entry1.s)
	return entry1.t + alpha * (entry2.t - entry1.t)
end

--- Evaluate curve at uniform arc length
function Curve:evaluateByArcLength(s)
	local t = self:arcLengthToParameter(s)
	return self:evaluate(t)
end

--[[============================================================================
	CURVATURE AND TORSION
============================================================================]]

--- Compute curvature at parameter t (2D and 3D)
function Curve:curvature(t)
	local vel = self:velocity(t)
	local acc = self:acceleration(t)

	local speed = distance(vel, getZero(vel))

	if speed < EPSILON then
		return 0
	end

	if isVector3(vel) then
		-- 3D curvature: κ = |v × a| / |v|³
		local cross = vel:Cross(acc)
		return cross.Magnitude / (speed * speed * speed)
	elseif isVector2(vel) then
		-- 2D curvature: κ = (x'y'' - y'x'') / (x'² + y'²)^(3/2)
		local numerator = abs(vel.X * acc.Y - vel.Y * acc.X)
		return numerator / (speed * speed * speed)
	else
		-- 1D case (always zero)
		return 0
	end
end

--- Compute torsion at parameter t (3D only)
function Curve:torsion(t)
	if not isVector3(self.points[1]) then
		return 0
	end

	local dt = 0.001
	local vel = self:velocity(t)
	local acc = self:acceleration(t)

	-- Third derivative (jerk)
	local jerk = scale(
		subtract(
			self:acceleration(min(1, t + dt)),
			acc
		),
		1 / dt
	)

	local cross1 = vel:Cross(acc)
	local mag = cross1.Magnitude

	if mag < EPSILON then
		return 0
	end

	-- τ = (v × a) · j / |v × a|²
	local torsion = cross1:Dot(jerk) / (mag * mag)
	return torsion
end

--- Compute Frenet-Serret frame (tangent, normal, binormal)
function Curve:frenetFrame(t)
	assert(isVector3(self.points[1]), "Frenet frame only defined for 3D curves")

	local vel = self:velocity(t)
	local acc = self:acceleration(t)

	-- Tangent
	local speed = vel.Magnitude
	if speed < EPSILON then
		return Vector3.new(1, 0, 0), Vector3.new(0, 1, 0), Vector3.new(0, 0, 1)
	end
	local tangent = vel / speed

	-- Binormal (T × T')
	local binormal = tangent:Cross(acc)
	local binormalMag = binormal.Magnitude
	if binormalMag < EPSILON then
		-- Choose arbitrary perpendicular
		local arbitrary = abs(tangent.X) < 0.9 and Vector3.new(1, 0, 0) or Vector3.new(0, 1, 0)
		binormal = tangent:Cross(arbitrary).Unit
	else
		binormal = binormal / binormalMag
	end

	-- Normal (B × T)
	local normal = binormal:Cross(tangent)

	return tangent, normal, binormal
end

--[[============================================================================
	CURVE OPERATIONS
============================================================================]]

--- Reverse curve direction
function Curve:reverse()
	local reversed = {}
	for i = #self.points, 1, -1 do
		insert(reversed, self.points[i])
	end
	self.points = reversed
	self:invalidateCache()
end

--- Concatenate another curve to this one
function Curve:concatenate(other)
	for _, point in ipairs(other.points) do
		insert(self.points, point)
	end
	self:invalidateCache()
end

--- Subdivide curve at parameter t
function Curve:subdivide(t)
	local curve1Points = {}
	local curve2Points = {}

	-- Sample first half
	local samples1 = ceil(#self.points * t)
	for i = 0, samples1 do
		insert(curve1Points, self:evaluate(i / samples1 * t))
	end

	-- Sample second half
	local samples2 = ceil(#self.points * (1 - t))
	for i = 0, samples2 do
		insert(curve2Points, self:evaluate(t + i / samples2 * (1 - t)))
	end

	return Curve.new({points = curve1Points, type = self.type}),
	Curve.new({points = curve2Points, type = self.type})
end

--- Simplify curve using Douglas-Peucker algorithm
function Curve:simplify(tolerance)
	tolerance = tolerance or 0.01

	local function pointLineDistance(point, lineStart, lineEnd)
		return distance(point, Curve.closestPointOnSegment(point, lineStart, lineEnd))
	end

	local function douglasPeucker(points, start, finish, tolerance, result)
		local maxDist = 0
		local maxIndex = 0

		for i = start + 1, finish - 1 do
			local dist = pointLineDistance(points[i], points[start], points[finish])
			if dist > maxDist then
				maxDist = dist
				maxIndex = i
			end
		end

		if maxDist > tolerance then
			douglasPeucker(points, start, maxIndex, tolerance, result)
			douglasPeucker(points, maxIndex, finish, tolerance, result)
		else
			insert(result, points[finish])
		end
	end

	local result = {self.points[1]}
	douglasPeucker(self.points, 1, #self.points, tolerance, result)

	self.points = result
	self:invalidateCache()
end

--- Offset curve by distance (2D only, approximate)
function Curve:offset(distance)
	assert(isVector2(self.points[1]), "Curve offsetting only implemented for 2D curves")

	local offsetPoints = {}

	for i, point in ipairs(self.points) do
		local t = (i - 1) / (#self.points - 1)
		local tangent = self:velocity(t)

		-- Normal is perpendicular to tangent
		local normal = Vector2.new(-tangent.Y, tangent.X)
		if normal.Magnitude > EPSILON then
			normal = normal.Unit
		end

		insert(offsetPoints, point + normal * distance)
	end

	return Curve.new({points = offsetPoints, type = self.type})
end

--[[============================================================================
	CURVE QUERIES
============================================================================]]

--- Find closest point on curve to given point
function Curve:closestPoint(point, samples)
	samples = samples or 100

	local minDist = huge
	local closestT = 0
	local closestPoint = self.points[1]

	for i = 0, samples do
		local t = i / samples
		local p = self:evaluate(t)
		local dist = distance(point, p)

		if dist < minDist then
			minDist = dist
			closestT = t
			closestPoint = p
		end
	end

	-- Refine with Newton-Raphson
	for iter = 1, 5 do
		local vel = self:velocity(closestT)
		local diff = subtract(self:evaluate(closestT), point)

		local numerator = 0
		local denominator = 0

		if isVector3(diff) then
			numerator = diff:Dot(vel)
			denominator = vel:Dot(vel)
		elseif isVector2(diff) then
			numerator = diff.X * vel.X + diff.Y * vel.Y
			denominator = vel.X * vel.X + vel.Y * vel.Y
		else
			numerator = diff * vel
			denominator = vel * vel
		end

		if abs(denominator) < EPSILON then
			break
		end

		local delta = numerator / denominator
		closestT = max(0, min(1, closestT - delta))
	end

	return self:evaluate(closestT), closestT, distance(point, self:evaluate(closestT))
end

--- Find closest point on line segment
function Curve.closestPointOnSegment(point, segStart, segEnd)
	local v = subtract(segEnd, segStart)
	local w = subtract(point, segStart)

	local c1, c2
	if isVector3(v) then
		c1 = v:Dot(w)
		c2 = v:Dot(v)
	elseif isVector2(v) then
		c1 = v.X * w.X + v.Y * w.Y
		c2 = v.X * v.X + v.Y * v.Y
	else
		c1 = v * w
		c2 = v * v
	end

	if c2 < EPSILON then
		return segStart
	end

	local t = max(0, min(1, c1 / c2))
	return lerp(segStart, segEnd, t)
end

--- Compute bounding box
function Curve:bounds()
	if self._cache.bounds then
		return self._cache.bounds
	end

	if #self.points == 0 then
		return nil
	end

	local minBound = self.points[1]
	local maxBound = self.points[1]

	for _, point in ipairs(self.points) do
		if isVector3(point) then
			minBound = Vector3.new(
				min(minBound.X, point.X),
				min(minBound.Y, point.Y),
				min(minBound.Z, point.Z)
			)
			maxBound = Vector3.new(
				max(maxBound.X, point.X),
				max(maxBound.Y, point.Y),
				max(maxBound.Z, point.Z)
			)
		elseif isVector2(point) then
			minBound = Vector2.new(
				min(minBound.X, point.X),
				min(minBound.Y, point.Y)
			)
			maxBound = Vector2.new(
				max(maxBound.X, point.X),
				max(maxBound.Y, point.Y)
			)
		else
			minBound = min(minBound, point)
			maxBound = max(maxBound, point)
		end
	end

	self._cache.bounds = {min = minBound, max = maxBound}
	return self._cache.bounds
end

--[[============================================================================
	SAMPLING AND EVALUATION
============================================================================]]

--- Evaluate curve at parameter t using the specified type
function Curve:evaluate(t)
	if #self.points == 0 then
		return nil
	end

	if #self.points == 1 then
		return self.points[1]
	end

	t = max(0, min(1, t))

	if self.type == "linear" or self.type == "polyline" then
		return Curve.polyline(self.points, t)
	elseif self.type == "bezier" then
		return Curve.bezier(self.points, t)
	elseif self.type == "bezierCubic" and #self.points == 4 then
		return Curve.bezierCubic(self.points[1], self.points[2], self.points[3], self.points[4], t)
	elseif self.type == "bezierQuadratic" and #self.points == 3 then
		return Curve.bezierQuadratic(self.points[1], self.points[2], self.points[3], t)
	elseif self.type == "catmullRom" then
		return Curve.catmullRom(self.points, t, self.alpha)
	elseif self.type == "hermite" then
		return Curve.hermiteInterpolate(self.points, t)
	elseif self.type == "bSpline" then
		return Curve.bSpline(self.points, t, self.degree)
	elseif self.type == "nurbs" then
		return Curve.nurbs(self.points, self.weights, self.knots, self.degree, t)
	elseif self.type == "tcb" then
		return Curve.kochanekBartels(self.points, t, self.tension, self.continuity, self.bias)
	else
		-- Default to Catmull-Rom
		return Curve.catmullRom(self.points, t, 0.5)
	end
end

--- Sample curve at uniform parameter intervals
function Curve:sample(count)
	count = count or 50
	local samples = {}

	for i = 0, count - 1 do
		local t = i / (count - 1)
		insert(samples, self:evaluate(t))
	end

	return samples
end

--- Sample curve at uniform arc length intervals
function Curve:sampleByArcLength(count)
	count = count or 50
	local samples = {}
	local totalLength = self:totalArcLength()

	for i = 0, count - 1 do
		local s = i / (count - 1) * totalLength
		insert(samples, self:evaluateByArcLength(s))
	end

	return samples
end

--- Adaptive sampling based on curvature
function Curve:adaptiveSample(maxCurvature, minSamples, maxSamples)
	maxCurvature = maxCurvature or 0.1
	minSamples = minSamples or 10
	maxSamples = maxSamples or 1000

	local samples = {self:evaluate(0)}
	local t = 0
	local step = 1 / minSamples

	while t < 1 and #samples < maxSamples do
		local k = self:curvature(t)

		-- Adapt step size based on curvature
		if k > EPSILON then
			step = min(0.1, maxCurvature / k)
		else
			step = 0.1
		end

		step = max(1 / maxSamples, min(1 / minSamples, step))

		t = min(1, t + step)
		insert(samples, self:evaluate(t))
	end

	return samples
end

--[[============================================================================
	UTILITY METHODS
============================================================================]]

--- Invalidate cache
function Curve:invalidateCache()
	self._cache = {
		arcLength = nil,
		arcLengthMap = nil,
		bounds = nil
	}
end

--- Get curve length
function Curve:length()
	return #self.points
end

--- Clone curve
function Curve:clone()
	local points = {}
	for _, p in ipairs(self.points) do
		insert(points, p)
	end

	return Curve.new({
		points = points,
		type = self.type,
		alpha = self.alpha,
		tension = self.tension,
		bias = self.bias,
		continuity = self.continuity,
		closed = self.closed,
		weights = self.weights,
		knots = self.knots,
		degree = self.degree
	})
end

--- Export to array format
function Curve:export(samples)
	samples = samples or 50
	local result = {}

	for i = 0, samples - 1 do
		local t = i / (samples - 1)
		local point = self:evaluate(t)
		insert(result, {t = t, point = point})
	end

	return result
end

--[[============================================================================
	STATIC UTILITY FUNCTIONS
============================================================================]]

--- Compute velocity between sampled points
function Curve.computeVelocity(points, t, dt, method)
	method = method or "catmullRom"
	dt = dt or 0.001

	local t0 = max(0, t - dt)
	local t1 = min(1, t + dt)

	local p0 = Curve[method](points, t0)
	local p1 = Curve[method](points, t1)

	return scale(subtract(p1, p0), 1 / (t1 - t0))
end

--- Fit curve to points using least squares (simplified)
function Curve.fit(points, degree, curveType)
	degree = degree or 3
	curveType = curveType or "bezier"

	-- For simplicity, just use subset of points as control points
	local step = max(1, floor(#points / (degree + 1)))
	local controlPoints = {}

	for i = 1, #points, step do
		insert(controlPoints, points[i])
	end

	return Curve.new({points = controlPoints, type = curveType, degree = degree})
end

return Curve
